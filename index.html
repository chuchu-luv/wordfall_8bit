<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>추억의 한컴타자-사고도구어(3수준)</title>
    <style>
        * { image-rendering: pixelated; }
        
        @font-face {
            font-family: 'DungGeunMo';
            src: url('DungGeunMo.ttf') format('truetype');
        }
        
        html,body {
            margin:0; padding:0; height:100%;
            font-family: 'DungGeunMo', system-ui, -apple-system, BlinkMacSystemFont, 'Malgun Gothic', sans-serif;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        
        .scanline {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,255,0,0.03) 0px, transparent 2px, transparent 4px);
            pointer-events: none; z-index: 9999;
            animation: flicker 0.15s infinite;
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 0.95; }
            50% { opacity: 1; }
        }
        
        .wrap { display:flex; flex-direction:column; height:100%; background: #000; }
        
        header, footer { padding:10px 12px; background: #111; border: 3px solid #0f0; }
        header { display:flex; align-items:center; gap:12px; flex-wrap:wrap; border-bottom: none; }
        
        .stat {
            background: #000; padding: 12px 16px; border: 2px solid #0f0; font-size: 16px; 
            color: #0f0; text-shadow: 0 0 5px #0f0; font-weight: bold;
        }
        
        .btn {
            background: #000; border: 3px solid #0f0; color: #0f0; padding: 12px 18px;
            cursor: pointer; font-size: 14px; font-family: 'DungGeunMo', monospace;
            text-shadow: 0 0 5px #0f0; transition: all 0.1s; font-weight: bold;
        }
        .btn:hover { background: #0f0; color: #000; }
        
        .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        
        #canvas { 
            width:100%; flex:1; display:block; background: #000;
            border-left: 3px solid #0f0; border-right: 3px solid #0f0;
        }
        
        .badge {
            padding: 8px 16px; border: 2px solid #0f0; background: #000;
            font-size: 14px; color: #0f0; text-shadow: 0 0 5px #0f0; font-weight: bold;
        }
        
        footer { 
            display:flex; justify-content:space-between; align-items:center; 
            font-size: 16px; color: #0f0; border-top: 3px solid #0f0; font-weight: bold;
        }
        
        .target { color: #ff0; text-shadow: 0 0 5px #ff0; font-size: 18px; }
        
        .game-over {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #000; padding: 30px; border: 4px solid #f00; text-align: center; 
            z-index: 1000; color: #f00; text-shadow: 0 0 5px #f00;
        }
        
        .game-over .btn { border-color: #f00; color: #f00; text-shadow: 0 0 5px #f00; }
        .game-over .btn:hover { background: #f00; color: #000; }
        
        .paused {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #000; padding: 30px; border: 4px solid #0f0; text-align: center; 
            z-index: 1000; color: #0f0;
        }
        
        .start-popup { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); display: flex; justify-content: center; 
            align-items: center; z-index: 2000; 
        }
        
        .start-content {
            background: #000; padding: 40px; border: 4px solid #0f0; text-align: center; 
            color: #0f0; max-width: 600px;
        }
        
        .start-btn {
            background: #000; border: 3px solid #0f0; color: #0f0; 
            padding: 15px 30px; cursor: pointer; font-size: 16px; 
            font-family: 'DungGeunMo', monospace; margin-top: 20px;
            text-shadow: 0 0 5px #0f0; font-weight: bold;
        }
        .start-btn:hover { background: #0f0; color: #000; }
        
        h1, h2 { text-shadow: 0 0 10px #0f0; }
        h1 { font-size: 20px; font-weight: bold; }
        h2 { font-size: 18px; margin: 0; font-weight: bold; }
        
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }
        
        .blink { animation: blink 1s infinite; }
    </style>
</head>
<body>
    <div class="scanline"></div>
    
    <div class="wrap" style="display:none;" id="gameWrap">
        <div style="text-align: center; padding: 15px 0; background: #000; border: 3px solid #0f0; border-bottom: none;">
            <h1 style="margin: 0;">추억의 한컴타자-사고도구어(3수준)</h1>
        </div>
        
        <header>
            <div class="row">
                <div class="stat">점수 <span id="score">0</span></div>
                <div class="stat">레벨 <span id="level">1</span></div>
                <div class="stat">콤보 <span id="combo">0</span></div>
                <div class="stat">HP <span id="hp">5</span></div>
            </div>
            <div class="row">
                <button class="btn" id="pauseBtn">일시정지</button>
                <button class="btn" id="restartBtn">재시작</button>
                <button class="btn" id="muteBtn">음소거</button>
            </div>
        </header>

        <canvas id="canvas"></canvas>

        <footer>
            <div>타겟: <span id="targetWord" class="target">---</span></div>
            <div class="badge">엔터를 눌러 제출</div>
        </footer>
    </div>

    <div style="position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); z-index: 1000; text-align: center; display:none;" id="inputWrap">
        <input id="hidInput" type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
            placeholder="여기에 입력하세요"
            style="padding: 18px 30px; font-size: 20px; border: 3px solid #0f0; 
            background: #000; color: #0f0; text-align: center; min-width: 400px;
            font-family: 'DungGeunMo', monospace; outline: none; text-shadow: 0 0 5px #0f0; font-weight: bold;" />
    </div>

    <div id="startPopup" class="start-popup">
        <div class="start-content">
            <h2 style="margin-bottom: 20px;">추억의 한컴타자-사고도구어(3수준)</h2>
            <p style="font-size: 14px; line-height: 1.8; margin-bottom: 15px; font-weight: bold;">
                타자게임으로 사고도구어를 익혀보세요!<br>
                떨어지는 단어를 입력하세요<br>엔터를 눌러 제출하세요<br>20개 단어마다 레벨 업!
            </p>
            <button class="start-btn blink" id="startBtn">시작하기</button>
        </div>
    </div>

   <audio id="bgm" loop autoplay> 
        <source src="Drum Or Bass.mp3" type="audio/mpeg">
    </audio>

    <script>
        const audio = document.getElementById('bgm');
        if (audio) {
            audio.volume = 0.3;
        }
    </script>
   
    <script>
const WORDS = ["가동","가상","가설","가정","감소","감축","강화","개념","개략","개발","개방","개별","개선","개요","개정","개척","검증","검토","격차","견고하다","결실","결점","결핍","결함","결합","경계","경과","경로","경제적","경향","계기","계량","계승","계층","고유","공격적","공공","공식","공유","공적","공존","과학적","관념","교대","교류","교정","교차","교체","구상","구성","구조","구체적","권고","규정","규제","균등","극단","극심하다","근본","근사","근원","근접","급등","급변","급속","급증","기관","기구","기술","기여","기원","기피","기획","긴밀하다","납득","내면적","내적","네트워크","노출","논거","논란","논리","논술","논의","논증","누출","능동","능률","능숙하다","능통","단일","단절","단축","달성","대등","대립","대상","대응","대의","대처","대체","대치","데이터","도약","도입","도출","독자적","동기","동반","동요","동원","동일","둔화","등재","디지털","마비","마찰","매체","면밀하다","명료성","명백하다","명확하다","모순","모의","모호성","몰입","묘사","무관하다","무능","무지","무한","무형","미비","미약하다","미흡하다","밀도","밀집","밀착","반론","반박","반발","반사","반영","반응","반전","발단","발상","발언","발의","발휘","방어","방치","방해","배분","번성","법적","변동","변별","변혁","변형","변환","보강","보급","보유","보조","보존","보편","복구","복원","복합","본격적","본질","부가","부류","부문","부여","부재","부착","분담","분배","분별","분산","분석","분야","분열","분출","분포","분할","분해","붕괴","비례","비약","비평","빅데이터","사태","사후","삽입","상관","상승","상위","상정","상징","상호","생성","서술","서열","선정","선진","선행","선호","선후","설계","설립","설문","설정","성립","성분","성찰","성취","성패","성행","성향","세부","소멸","소실","소양","소외","소화","속박","속성","손상","쇠퇴","수동적","수락","수반","수신","수여","수월하다","수축","수행","순응","시초","시행","신장","실례","실용","실제","실체","실태","실현","심화","아날로그","아이러니","악순환","악영향","악화","암시","압도","압력","압축","약세","약화","양면","양상","양성","양식","억제","엄밀성","엄정하다","여건","여부","여분","역량","역부족","역사적","역설","역설하다","역전","역점","연관","연립","연상","연속","연쇄","연장","연합","열거","영구","영역","예견","예비","오류","완결","완료","완수","완화","외래","외적","요소","요원하다","요인","요지","용례","용이하다","용인","우려","운용","원동력","원리","원천","원칙","위축","유념","유망","유발","유의미","유일","유입","유추","유출","유포","유한","유형","융합","음성","응용","의거하다","의결","의사","의식","의지하다","이견","이론","이면","이상적","이성","이송","이슈","이의","이익","이지적","이질","이치","인공","인과","인증","인지","인하다","일괄","일반","일방적","일시적","일절","일정하다","일차적","일치","입장","자립","자발","자연적","자율","자질","자체","작용","장려","장벽","재래","재생","재현","저장","저항","적대","적용","적응","적절하다","적합","전개","전국적","전략","전망","전문","전반적","전송","전용","전제","전진","전통적","전파","전환","절감","절대","점검","접근","접속","정밀","정비","정서적","정수","정식","정신적","정오","정의","정점","정정","정제","정착","정화","제거","제공","제기","제시","제약","제어","제외","제작","제조","제출","제한","조력","조장","조절","조정","조종","조직","조치","조화","존속","존재","종결","종합","주관","주도","주류","주목","주요","주입","주종","주체","준거","중계","중단","중대","중재","중점","중지","증가","증대","증진","지구적","지리적","지배","지수","지적","지체","지칭","지향","직면","진단","진술","진입","진전","진취적","진행","진흥","집단적","집약","집합","차등","차원","참고","참조","창시","창출","채취","채택","처분","처치","천연","철회","첨가","첨단","첨부","체계","초래","초석","초월","초점","총체","추가","추구","추락","추론","추상","추적","추종","추진","추후","축소","축적","출현","충당","충전","취급","취지","치열하다","치중하다","콘텐츠","통계적","통보","통찰","통합","투사","투영","특수","특유","특이","특정","특질","파손","파열","팽배","팽창","편성","편중","편찬","평형","폐쇄","포섭","폭발적","표면","표절","표출","프로젝트","필사적","필연","하강","하락","한계","한도","한정","할당","함양","함유","합당하다","합리","합산","합의","해박","해소","행태","향후","허용","혁신","현대적","현상","현존","현황","형상","형성","형식","형평","호응","혼돈","혼용","혼합","확대","확률","확립","확보","확산","확연","확장","확정","확충","환경적","회복","회피","획득","획일성","효능","효력","효용","효율","후속","희소"];

let buckets = {2:[], 3:[], 4:[]};
WORDS.forEach(w => {
    const len = [...w].length;
    if(len === 2) buckets[2].push(w);
    else if(len === 3) buckets[3].push(w);
    else if(len === 4) buckets[4].push(w);
});

let state = {
    score:0, level:1, combo:0, maxCombo:0, hp:5, 
    correct:0, total:0, words:[], lastSpawn:0, target:null,
    over:false, paused:false, muted:false, started:false,
    lastWord:'', lastChar:'', charCount:0
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('hidInput');
const bgm = document.getElementById('bgm'); 
const els = {
    score: document.getElementById('score'),
    level: document.getElementById('level'),
    combo: document.getElementById('combo'),
    hp: document.getElementById('hp'),
    target: document.getElementById('targetWord'),
    pauseBtn: document.getElementById('pauseBtn'),
    restartBtn: document.getElementById('restartBtn'),
    muteBtn: document.getElementById('muteBtn'),
    startBtn: document.getElementById('startBtn'),
    startPopup: document.getElementById('startPopup'),
    gameWrap: document.getElementById('gameWrap'),
    inputWrap: document.getElementById('inputWrap')
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function beep(freq, dur) {
    if(state.muted) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + dur);
    } catch(e) {}
}

function getConfig(lv) {
    const cfgs = {
        1: {speed:8, interval:2.5, max:2},
        2: {speed:12, interval:2.0, max:3},
        3: {speed:16, interval:1.7, max:4},
        4: {speed:20, interval:1.4, max:5}
    };
    return cfgs[lv] || {speed:20+2*(lv-4), interval:0.8, max:5};
}

function pickWord() {
    if(state.level === 1 && buckets[2].length) {
        return buckets[2][Math.floor(Math.random()*buckets[2].length)];
    }
    const mix = state.level===1 ? [1,0,0] : state.level===2 ? [0.6,0.4,0] : [0.3,0.5,0.2];
    const r = Math.random();
    let size = r < mix[0] ? 2 : (r < mix[0]+mix[1] ? 3 : 4);
    if(!buckets[size].length) size = 2;
    const bkt = buckets[size];
    let w, tries = 0;
    do {
        w = bkt[Math.floor(Math.random()*bkt.length)];
        tries++;
    } while(tries<10 && (w===state.lastWord || (w[0]===state.lastChar && state.charCount>=2)));
    if(w[0]===state.lastChar) state.charCount++; 
    else { state.charCount=1; state.lastChar=w[0]; }
    state.lastWord = w;
    return w;
}

class Word {
    constructor(txt) {
        this.text = txt;
        this.size = 24;
        this.font = `bold ${this.size}px 'DungGeunMo', monospace`;
        ctx.font = this.font;
        this.width = ctx.measureText(txt).width;
        this.x = Math.random()*(canvas.width - this.width);
        this.y = -this.size;
        this.speed = getConfig(state.level).speed;
        this.age = 0;
        this.isTarget = false;
        this.birth = Date.now();
        this.isFlickering = false;
        this.flickerTime = 0; 
    }
    update(dt) {
        if (!this.isFlickering) {
            this.age += dt/1000;
            this.speed = getConfig(state.level).speed * (1 + 0.12*this.age);
            this.y += (this.speed/100) * window.innerHeight * (dt/1000);
        } else {
            this.flickerTime += dt;
        }
    }
    draw() {
        if (this.isFlickering) {
            if (Math.floor(this.flickerTime / 50) % 2 === 0) {
                return;
            }
        }
        
        ctx.font = this.font;
        let clr = this.isTarget ? '#ff0' : '#0f0';
        if(this.y > canvas.height*0.85) clr = '#f00';
        if (this.isFlickering) {
            clr = '#f00';
        }
        
        ctx.fillStyle = clr;
        ctx.shadowBlur = 10;
        ctx.shadowColor = clr;
        ctx.fillText(this.text, this.x, this.y);
        ctx.shadowBlur = 0;
        if(this.isTarget && !this.isFlickering) { 
            ctx.strokeStyle = clr;
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x-5, this.y-this.size-5, this.width+10, this.size+10);
        }
    }
    atBottom() { return this.y > canvas.height*0.9; }
}

function spawn() {
    const cfg = getConfig(state.level);
    const now = Date.now();
    const activeWords = state.words.filter(w => !w.isFlickering);
    
    if(activeWords.length < cfg.max && now - state.lastSpawn > cfg.interval*1000) {
        const txt = pickWord();
        if(txt) {
            state.words.push(new Word(txt));
            state.lastSpawn = now;
            updateTarget();
        }
    }
}

function updateTarget() {
    state.words.forEach(w => w.isTarget = false);
    const activeWords = state.words.filter(w => !w.isFlickering);
    
    if(activeWords.length) {
        let bot = activeWords[0];
        activeWords.forEach(w => { if(w.y > bot.y) bot = w; });
        bot.isTarget = true;
        state.target = bot;
        els.target.textContent = bot.text;
    } else {
        state.target = null;
        els.target.textContent = '---';
    }
}

function complete(word) {
    const time = (Date.now() - word.birth)/1000;
    const pts = Math.round((10 + 2*word.text.length) * (1 + state.combo*0.02));
    state.score += pts;
    state.combo++;
    if(state.combo > state.maxCombo) state.maxCombo = state.combo;
    state.correct++;
    beep(880, 0.05);
    
    word.isFlickering = true;
    word.isTarget = false;
    updateTarget(); 

    const nl = Math.floor(state.correct/20) + 1;
    if(nl > state.level) state.level = nl;
    updateUI();
}

function miss() {
    state.combo = 0;
    state.hp--;
    beep(110, 0.15);
    if(state.hp <= 0) {
        gameOver();
        bgm.pause();
    }
    updateUI();
}

function gameOver() {
    state.over = true;
    const d = document.createElement('div');
    d.className = 'game-over';
    d.innerHTML = `<h2>게임 오버!</h2><p>점수: ${state.score}</p><p>최대 콤보: ${state.maxCombo}</p><button class="btn" onclick="location.reload()">재시작</button>`;
    document.body.appendChild(d);
}

function handleEnter() {
    const txt = input.value.trim();
    if(!txt) return;
    state.total++;
    
    const activeWords = state.words.filter(w => !w.isFlickering);
    
    if(state.target && txt === state.target.text && !state.target.isFlickering) {
        complete(state.target);
        input.value = '';
        return;
    }
    for(const w of activeWords) {
        if(txt === w.text) {
            complete(w);
            input.value = '';
            return;
        }
    }
    state.combo = 0;
    beep(110, 0.15);
    input.value = '';
    updateUI();
}

function updateUI() {
    els.score.textContent = state.score;
    els.level.textContent = state.level;
    els.combo.textContent = state.combo;
    els.hp.textContent = state.hp;
}

let last = 0;
function loop(t) {
    if(!last) { last = t; requestAnimationFrame(loop); return; }
    const dt = Math.min(t - last, 100);
    last = t;
    
    if(!state.over && !state.paused && state.started) {
        if(canvas.width !== canvas.offsetWidth || canvas.height !== canvas.offsetHeight) {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const line = canvas.height * 0.9;
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#f00';
        ctx.beginPath();
        ctx.moveTo(0, line);
        ctx.lineTo(canvas.width, line);
        ctx.stroke();
        ctx.shadowBlur = 0;
        
        spawn();
        for(let i = state.words.length-1; i >= 0; i--) {
            const w = state.words[i];
            
            if (w.isFlickering && w.flickerTime > 200) {
                 state.words.splice(i, 1);
                 updateTarget();
                 continue;
            }
            
            w.update(dt);
            w.draw();
            
            if(w.atBottom()) {
                state.words.splice(i, 1);
                miss();
                updateTarget();
            }
        }
    }
    requestAnimationFrame(loop);
}

function startGame() {
    els.startPopup.style.display = 'none';
    els.gameWrap.style.display = 'flex';
    els.inputWrap.style.display = 'block';
    state.started = true;
    input.focus();
    if(!state.muted) {
        bgm.play().catch(e => {
            console.log("Background music autoplay blocked, manually playing on interaction.");
        });
    }
}

function pause() {
    state.paused = !state.paused;
    els.pauseBtn.textContent = state.paused ? '재개' : '일시정지';
    if(state.paused) {
        const d = document.createElement('div');
        d.className = 'paused';
        d.id = 'pauseOver';
        d.innerHTML = '<h2>일시정지</h2>';
        document.body.appendChild(d);
        bgm.pause();
    } else {
        const d = document.getElementById('pauseOver');
        if(d) d.remove();
        input.focus();
        if(!state.muted) {
            bgm.play().catch(e => {});
        }
    }
}

els.startBtn.onclick = startGame;
els.pauseBtn.onclick = pause;
els.restartBtn.onclick = () => location.reload();
els.muteBtn.onclick = () => {
    state.muted = !state.muted;
    els.muteBtn.textContent = state.muted ? '음소거 해제' : '음소거';
    if(state.muted) {
        bgm.pause();
    } else if(state.started && !state.paused) {
        bgm.play().catch(e => {});
    }
};

input.addEventListener('keydown', e => {
    if(e.key === 'Enter') handleEnter();
});

document.addEventListener('click', () => {
    if(!state.over && !state.paused && state.started) input.focus();
});

// 다른 페이지로 이동하거나 새로고침할 때 배경음악 완전히 정지
window.addEventListener('beforeunload', () => {
    try {
        if (bgm) {
            bgm.pause();
            bgm.currentTime = 0;
        }
        if (audioCtx && typeof audioCtx.close === 'function') {
            audioCtx.close();
        }
    } catch(e) {}
});

// 탭이 숨겨질 때도 음악 정지 (필요 없으면 이 부분 지워도 됨)
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        try {
            if (bgm) bgm.pause();
        } catch(e) {}
    }
});

canvas.width = canvas.offsetWidth;
canvas.height = canvas.offsetHeight;
requestAnimationFrame(loop);
    </script>
</body>
</html>
